use std::time::Instant;

use spf::*;

//  +---+ +---+ +---+ +---+
//  | 0 |-| 1 |-|...|-|n-1|
//  +---+ +---+ +---+ +---+
//    |     |     |     |
//  +---+ +---+ +---+ +---+
//  | n |-|n+1|-|...|-|2n|
//  +---+ +---+ +---+ +---+
//    |     |     |     |
//  +---+ +---+ +---+ +---+
//  |Xn |-| 1 |-|...|-|   |
//  +---+ +---+ +---+ +---+
//
pub fn matrix_toplogy(n: usize, opt: &SpfOpt) {
    let mut graph = vec![];
    for i in 0..n {
        for j in 0..n {
            let id = (i * n) + j;
            let mut node = Node::new(&id.to_string(), id);
            // Vertical link: do not create vertical link for bottom row.
            if i != n - 1 {
                // Link from id to id + n.
                let link = Link::new(id, id + n, 10);
                node.olinks.push(link);
            }
            // Horisontal link: do not create horisontal link for most right column.
            if j != n - 1 {
                // Link from id to id + n.
                let link = Link::new(id, id + 1, 10);
                node.olinks.push(link);
            }
            graph.push(node);
        }
    }

    let now = Instant::now();
    let spf = spf_normal(&graph, 0, opt.full_path, opt.path_max);
    println!("n:{} {:?}", n, now.elapsed());

    assert_eq!(spf.len(), 10000); // 100 x 100

    // disp(&spf, opt.full_path)
}

#[test]
pub fn matrix() {
    // We have two option in path/nexthop calculation.
    //
    // When full_path is true,
    //
    // metric 1980 path [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 299, 399, 499, 599, 699, 799, 899, 999, 1099, 1199, 1299, 1399, 1499, 1599, 1699, 1799, 1899, 1999, 2099, 2199, 2299, 2399, 2499, 2599, 2699, 2799, 2899, 2999, 3099, 3199, 3299, 3399, 3499, 3599, 3699, 3799, 3899, 3999, 4099, 4199, 4299, 4399, 4499, 4599, 4699, 4799, 4899, 4999, 5099, 5199, 5299, 5399, 5499, 5599, 5699, 5799, 5899, 5999, 6099, 6199, 6299, 6399, 6499, 6599, 6699, 6799, 6899, 6999, 7099, 7199, 7299, 7399, 7499, 7599, 7699, 7799, 7899, 7999, 8099, 8199, 8299, 8399, 8499, 8599, 8699, 8799, 8899, 8999, 9099, 9199, 9299, 9399, 9499, 9599, 9699, 9799, 9899, 9999]
    // metric 1980 path [0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 168, 169, 170, 171, 172, 173, 174, 175, 176, 177, 178, 179, 180, 181, 182, 183, 184, 185, 186, 187, 188, 189, 190, 191, 192, 193, 194, 195, 196, 197, 198, 199, 299, 399, 499, 599, 699, 799, 899, 999, 1099, 1199, 1299, 1399, 1499, 1599, 1699, 1799, 1899, 1999, 2099, 2199, 2299, 2399, 2499, 2599, 2699, 2799, 2899, 2999, 3099, 3199, 3299, 3399, 3499, 3599, 3699, 3799, 3899, 3999, 4099, 4199, 4299, 4399, 4499, 4599, 4699, 4799, 4899, 4999, 5099, 5199, 5299, 5399, 5499, 5599, 5699, 5799, 5899, 5999, 6099, 6199, 6299, 6399, 6499, 6599, 6699, 6799, 6899, 6999, 7099, 7199, 7299, 7399, 7499, 7599, 7699, 7799, 7899, 7999, 8099, 8199, 8299, 8399, 8499, 8599, 8699, 8799, 8899, 8999, 9099, 9199, 9299, 9399, 9499, 9599, 9699, 9799, 9899, 9999]
    //
    // When full_path is false, it only tracks unique nexthop lists.
    //
    // node: 9999 nexthops: 2
    //   metric 1980 path [0, 100]
    //   metric 1980 path [0, 1]
    //
    let opt = SpfOpt {
        full_path: true,
        path_max: 32,
        srv6: false,
        srmpls: true,
    };
    matrix_toplogy(100, &opt);
}
